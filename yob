#!/usr/bin/ruby

require 'rubygems'
require 'gpgme'
require 'sqlite3'
require 'tempfile'
require 'yaml'

class Yob
  ConfigurationError = Class.new(StandardError)

  module Database
    class Base
      attr_reader :configuration, :keys, :store

      def initialize(configuration, keys, store)
        @configuration = configuration
        @keys = keys
        @store = store
      end

      protected
      def encrypt_and_store_pipe(filename_strftime_format)
        reader, writer = IO.pipe
        fork do
          reader.close
          yield writer
          writer.close unless writer.closed?
          exit 0
        end

        writer.close
        encrypt_and_store_from_io(reader, filename_strftime_format)
      end

      def encrypt_and_store_from_io(io, filename_strftime_format, close_io = true)
        stats = io.stat
        Tempfile.open("yob") do |tempfile|
          tempfile.unlink

          puts "encrypting started"
          GPGME.encrypt(keys, io, tempfile, :always_trust => true)
          puts "encrypting done"

          io.close if io.respond_to?(:close) && close_io
          tempfile.rewind

          filename = Time.now.strftime(filename_strftime_format)

          puts "passing to store"
          @store.store filename, tempfile
          puts "stored"
        end
      end

      def random_filename_string
        (0..15).inject(".") {|s, i| s << (97 + rand(26)).chr} if configuration.fetch('randomise_filename')
      end
    end

    class Mysql < Base
      def initialize(configuration, keys, store)
        super
        unless File.directory?(configuration["mysql_log_directory"])
          raise Yob::ConfigurationError, "mysql_log_directory does not exist"
        end

        unless File.exists?(configuration["mysqldump_executable"])
          raise Yob::ConfigurationError, "mysqldump_executable does not exist"
        end

        @db = SQLite3::Database.new(configuration.fetch("file_database", "#{File.dirname(__FILE__)}/yob.db"))
        @db.execute("CREATE TABLE IF NOT EXISTS files (id INTEGER PRIMARY KEY AUTOINCREMENT, filename varchar(255) unique not null, file_size integer not null, file_time datetime not null)")
      end

      def full_backup
        encrypt_and_store_pipe("%Y%m%d-%H%M%S#{random_filename_string}.sql.gpg") do |writer|
          system("#{configuration["mysqldump_executable"]} --all-databases --skip-opt --create-options --add-drop-database --extended-insert --flush-logs --master-data --quick --single-transaction >&#{writer.fileno}")
        end
      end

      def partial_backup
        files = Dir["#{configuration["mysql_log_directory"]}/mysql-bin.*"]
        files.each do |filename|
          next if filename[-5..-1] == 'index'

          stats = File.stat(filename)
          file_time = stats.mtime.strftime("%Y-%m-%d %H:%M:%S")

          row = @db.get_first_row("SELECT id, file_size, file_time FROM files WHERE filename = ?", filename)
          if row && row[1].to_i == stats.size && row[2] == file_time
            puts "skipping #{filename}"
          else
            File.open(filename, "r") do |logfile|
              encrypt_and_store_from_io logfile, "#{File.basename(filename)}#{random_filename_string}.gpg"
            end

            if row
              @db.execute("UPDATE files SET file_size = ?, file_time = ? WHERE id = ?", stats.size, file_time, row[0])
            else
              stmt = @db.prepare("INSERT INTO files (filename, file_size, file_time) VALUES (?, ?, ?)")
              stmt.execute(filename, stats.size, file_time)
            end
          end
        end
      end
    end

    class Postgresql < Base
      def initialize(configuration, keys, store)
        super
        require 'archive/tar/minitar'
      end

      def full_backup
        require 'pg'

        connect_and_execute "SELECT pg_start_backup('yob')"

        begin
          encrypt_and_store_pipe("%Y%m%d-%H%M%S#{random_filename_string}.tar.gpg") do |writer|
            puts "tar starting"
            tar = Archive::Tar::Minitar::Output.new(writer)
            begin
              Find.find(configuration.fetch("postgresql_data_directory")) do |entry|
                Archive::Tar::Minitar.pack_file(entry, tar) unless entry.include?("/pg_xlog/")
              end
            ensure
              tar.close
            end
            puts "tar finished"
          end

        ensure
          connect_and_execute "SELECT pg_stop_backup()"
        end
      end

      def partial_backup
        raise "yob partial must be called with two more arguments - the full path and the destination filename - for a postgresql partial backup" unless ARGV.length == 3
        full_path = ARGV[1]
        destination_filename = ARGV[2]

        File.open(full_path, "r") do |file|
          encrypt_and_store_from_io file, "#{destination_filename}#{random_filename_string}"
        end
      end

      protected
      def connect_and_execute(sql)
        hostname = @configuration["postgresql_hostname"]
        port = @configuration["postgresql_port"]
        if hostname || port
          hostname ||= "localhost"
          port ||= 5432
        end

        connection = PGconn.connect(
          hostname, # nil if UNIX socket
          port,     # nil if UNIX socket
          '',       # options
          '',       # unused by library
          @configuration.fetch("postgresql_default_database", "postgres"),
          @configuration["postgresql_username"],
          @configuration["postgresql_password"])

        connection.exec(sql)
        connection.close
      end
    end
  end

  module Store
    class AWS
      def initialize(configuration)
        require 'aws/s3'
        @configuration = configuration
        AWS::S3::Base.establish_connection!(:access_key_id => configuration["aws_access_key_id"], :secret_access_key => configuration["aws_secret_access_key"])
      end

      def store(filename, file_handle)
        puts "uploading #{filename}"
        AWS::S3::S3Object.store(filename, file_handle, @configuration["aws_bucket"])
        grant_access_to_file(filename)
        puts "uploaded"
      end

      protected
      def grant_access_to_file(file)
        grant = AWS::S3::ACL::Grant.new
        grant.permission = "FULL_CONTROL"
        grant.grantee = AWS::S3::ACL::Grantee.new
        grant.grantee.email_address = "accounts@youdo.co.nz"

        policy = AWS::S3::S3Object.acl(file, @configuration["aws_bucket"])
        policy.grants << grant
        AWS::S3::S3Object.acl(file, @configuration["aws_bucket"], policy)
      end
    end

    class Boat
      attr_reader :configuration

      def initialize(configuration)
        require 'boat'
        @configuration = configuration
      end

      def store(filename, file_handle)
        puts "connecting to boat server"
        @boat ||= ::Boat::Client.new(configuration.fetch("boat_username"), configuration.fetch("boat_key"), configuration.fetch("boat_hostname"), configuration["boat_options"] || {})
        puts "uploading #{filename}"
        @boat.put file_handle, filename
        puts "uploaded"
      end
    end
  end


  def initialize(configuration)
    keys = configuration["encryption_key_names"].collect {|name| GPGME.list_keys(name).first}
    raise ConfigurationError, "One or more encryption keys not found in GnuPG keychain" if keys.empty? || !keys.all?

    @configuration = configuration
    store = store_handler_class.new(configuration)
    @database = database_handler_class.new(configuration, keys, store)
  end

  def full_backup
    @database.full_backup do |filename, file_handle|
      @store.store(filename, file_handle)
    end
  end

  def partial_backup
    @database.partial_backup do |filename, file_handle|
      @store.store(filename, file_handle)
    end
  end

  def database_handler_class
    case @configuration.fetch("database_handler").downcase
    when "postgresql" then Database::Postgresql
    when "mysql"      then Database::Mysql
    else                   raise "Unrecognised database_handler"
    end
  end

  def store_handler_class
    case @configuration.fetch("storage_handler").downcase
    when "boat" then Store::Boat
    when "aws"  then Store::AWS
    else             raise "Unrecognised storage_handler"
    end
  end
end


if ARGV.length.zero? || !%w(full partial).include?(ARGV[0])
  puts "specify 'full' or 'partial' on the command line"
  exit 1
end

yob_yml = ["/etc/yob.yml", File.dirname(__FILE__) << "/yob.yml"].detect {|file| File.exists?(file)}

raise "could not locate a yob.yml file in any of the normal locations" unless yob_yml

configuration = YAML.load(IO.read(yob_yml))["configuration"]

yob = Yob.new(configuration)
if ARGV[0] == 'full'
  yob.full_backup
else
  yob.partial_backup
end
