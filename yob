#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'
require 'yaml'

class Yob
  class Configuration
    Error = Class.new(StandardError)

    def initialize(hash)
      @hash = hash
    end

    def [](key)
      @hash[key.to_s]
    end

    def fetch(key, default)
      @hash[key.to_s] || default
    end

    def method_missing(key, *args)
      key = key.to_s
      raise Error, "Required configuration parameter '#{key}' not specified in configuration file" unless @hash.member?(key)
      @hash[key]
    end
  end

  module Database
    class Base
      attr_reader :configuration

      def initialize(configuration)
        @configuration = configuration
      end

      protected
      def random_filename_string
        (0..15).inject(".") {|s, i| s << (97 + rand(26)).chr} if configuration["randomise_filename"]
      end
    end

    class Mysql < Base
      def initialize(configuration)
        super

        unless File.directory?(configuration.mysql_log_directory)
          raise Yob::Configuration::Error, "mysql_log_directory does not exist"
        end

        unless File.exists?(configuration.mysqldump_executable)
          raise Yob::Configuration::Error, "mysqldump_executable does not exist"
        end
      end

      def full_backup
        writer = yield Time.now.strftime("%Y%m%d-%H%M%S#{random_filename_string}.sql.gpg"), nil
        system("#{configuration.mysqldump_executable} --all-databases --default-character-set=utf8 --skip-opt --create-options --add-drop-database --extended-insert --flush-logs --master-data --quick --single-transaction >&#{writer.fileno}")
        writer.close
      end

      def partial_backup
        require 'sqlite3'

        @db = SQLite3::Database.new(configuration.fetch("file_database", "#{File.dirname(__FILE__)}/yob.db"))
        @db.execute("CREATE TABLE IF NOT EXISTS files (id INTEGER PRIMARY KEY AUTOINCREMENT, filename varchar(255) unique not null, file_size integer not null, file_time datetime not null)")

        files = Dir["#{configuration.mysql_log_directory}/mysql-bin.*"]
        files.each do |filename|
          next if filename[-5..-1] == 'index'

          stats = File.stat(filename)
          file_time = stats.mtime.strftime("%Y-%m-%d %H:%M:%S")

          row = @db.get_first_row("SELECT id, file_size, file_time FROM files WHERE filename = ?", filename)
          if row && row[1].to_i == stats.size && row[2] == file_time
            puts "skipping #{filename}"
          else
            File.open(filename, "r") do |logfile|
              yield "#{File.basename(filename)}#{random_filename_string}.gpg", logfile
            end

            if row
              @db.execute("UPDATE files SET file_size = ?, file_time = ? WHERE id = ?", stats.size, file_time, row[0])
            else
              stmt = @db.prepare("INSERT INTO files (filename, file_size, file_time) VALUES (?, ?, ?)")
              stmt.execute(filename, stats.size, file_time)
            end
          end
        end
      end
    end

    class Postgresql < Base
      def initialize(configuration)
        super
        require 'archive/tar/minitar'
      end

      def full_backup
        require 'pg'

        connect_and_execute "SELECT pg_start_backup('yob')"

        begin
          writer = yield Time.now.strftime("%Y%m%d-%H%M%S#{random_filename_string}.tar.gpg"), nil
          tar = Archive::Tar::Minitar::Output.new(writer)
          begin
            Find.find(configuration.postgresql_data_directory) do |entry|
              Archive::Tar::Minitar.pack_file(entry, tar) unless entry.include?("/pg_xlog/")
            end
          ensure
            tar.close
          end
          writer.close
        ensure
          connect_and_execute "SELECT pg_stop_backup()"
        end
      end

      def partial_backup
        raise "yob partial must be called with two more arguments - the full path and the destination filename - for a postgresql partial backup" unless ARGV.length == 3
        full_path = ARGV[1]
        destination_filename = ARGV[2]

        File.open(full_path, "r") do |file|
          yield "#{destination_filename}#{random_filename_string}", file
        end
      end

      protected
      def connect_and_execute(sql)
        hostname = @configuration.fetch("postgresql_hostname", "localhost")
        port = @configuration.fetch("postgresql_port", 5432)

        connection = PGconn.connect(
          hostname, # nil if UNIX socket
          port,     # nil if UNIX socket
          '',       # options
          '',       # unused by library
          @configuration.fetch("postgresql_default_database", "postgres"),
          @configuration["postgresql_username"],
          @configuration["postgresql_password"])

        connection.exec(sql)
        connection.close
      end
    end
  end

  module Store
    class AWS
      BLOCK_SIZE = 1048576

      def initialize(configuration)
        require 'aws-sdk'

        @configuration = configuration

        ::AWS.config(:access_key_id     => configuration.aws_access_key_id,
                     :secret_access_key => configuration.aws_secret_access_key)
      end

      def storage_input_pipe(filename)
        rd, wr = IO.pipe
        fork do
          $0 = "yob: AWS S3 storage"
          wr.close
          IO.select([rd]) # wait until there's some input before starting up the storage to prevent timeouts
          store(filename, rd)
        end
        rd.close
        wr
      end

      def store(filename, file_handle)
        puts "Store::AWS: uploading #{filename}"
        object = ::AWS::S3.new.buckets[@configuration.aws_bucket].objects["#{@configuration["aws_filename_prefix"]}#{filename}"]
        object.multipart_upload do |upload|
          print "Store::AWS: multipart upload started\n" if @configuration.debug
          bytes = 0
          while data = file_handle.read(BLOCK_SIZE)
            break if data.length == 0
            bytes += data.length
            upload.add_part(data)
            print "Store::AWS: #{bytes} bytes sent\n" if @configuration.debug
          end
        end
        puts "Store::AWS: #{object.content_length} bytes stored"

        if grant_to = @configuration["aws_grant_access_to"]
          puts "Store::AWS: granting access to #{filename}"
          object.acl = access_control_list(grant_to)
        end

        puts "Store::AWS: uploaded"
      end

      protected
      def access_control_list(email)
        acl = ::AWS::S3::AccessControlList.new
        acl.grant(:full_control).to(:amazon_customer_email => email)
        acl
      end
    end
  end

  module Encrypt
    class GnuPG
      def initialize(configuration)
        require 'gpgme'
        @keys = configuration.encryption_key_names
      end

      def encryption_input_pipe(output_pipe)
        rd, wr = IO.pipe
        fork do
          $0 = "yob: GnuPG encryption"
          wr.close
          encrypt(rd, output_pipe)
        end
        rd.close
        wr
      end

      def encrypt(rd, wr)
        puts "Encrypt::GnuPG: encrypting input"

        plain_data = GPGME::Data.new(rd)
        cipher_data = GPGME::Data.new(wr)
        keys = GPGME::Key.find(:public, @keys)

        GPGME::Ctx.new do |ctx|
          ctx.encrypt(keys, plain_data, cipher_data, GPGME::ENCRYPT_ALWAYS_TRUST)
        end

        puts "Encrypt::GnuPG: encrypting complete"
      end
    end
  end

  def initialize(configuration)
    @configuration = Configuration.new(configuration)
    @store = store_handler_class.new(@configuration)
    @encryption = Encrypt::GnuPG.new(@configuration)
    @database = database_handler_class.new(@configuration)
  end

  def backup(type)
    @database.send(type) do |filename, rd|
      storage_pipe = @store.storage_input_pipe(filename)
      if rd
        @encryption.encrypt(rd, storage_pipe)
        nil
      else
        @encryption.encryption_input_pipe(storage_pipe)
      end
    end
  end

  protected
  def database_handler_class
    case @configuration.database_handler.downcase
    when "postgresql" then Database::Postgresql
    when "mysql"      then Database::Mysql
    else                   raise "Unrecognised database_handler"
    end
  end

  def store_handler_class
    case @configuration.storage_handler.downcase
    when "aws"  then Store::AWS
    else             raise "Unrecognised storage_handler"
    end
  end
end


command_line_options = {}
configuration_path = ["/etc/yob.yml", File.dirname(__FILE__) << "/yob.yml"].detect {|file| File.exists?(file)}

OptionParser.new(ARGV) do |opts|
  opts.banner = "Usage: yob [options] full|partial"

  opts.on("--debug", "Print debug output") do
    command_line_options["debug"] = true
  end

  opts.on("-c", "--config CONFIG_FILE", String, "Specify a path to the configuration file") do |file|
    configuration_path = file
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end.parse!

if ARGV.length.zero? || !%w(full partial).include?(ARGV[0])
  puts "specify 'full' or 'partial' on the command line"
  exit 1
end

raise "could not locate a yob.yml file in any of the normal locations" unless configuration_path

configuration = YAML.load(IO.read(configuration_path))["configuration"]

begin
  yob = Yob.new(configuration.merge(command_line_options))
  if ARGV[0] == 'full'
    yob.backup :full_backup
  else
    yob.backup :partial_backup
  end
rescue Yob::Configuration::Error => e
  $stderr.puts e.message
  exit 1
end
